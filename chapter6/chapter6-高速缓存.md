# chapter 6-存储器层次结构

## 习题6.17

```c
typedef int array[2][2];

void transpose1(array dst, array src) {
    int i, j;
    
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 2; j++) {
            dst[j][i] = src[i][j];
        }
    }
}
```

- sizeof(int)=4

- src数组地址 =  0x0，dst数组地址 = 0x10
- L1数据高速缓存，直写和写分配的：

| 组   |      | 块大小 |
| ---- | ---- | ------ |
| 组0  |      | 8字节  |
| 组1  |      | 8字节  |

访问`src[0][0]`, 不命中, 加载8字节的块到组0，此时`src[0][1]`也在组0了；

写入`dst[0][0]`, 不命中，由于是写分配，加载L2的8字节的块到组0写入，此时src的组0缓存行被替换，`dst[0][1]`也在组0缓存行；

访问`src[0][1]`, 不命中，加载8字节的块到组0，此时`src[0][1]`也在组0了，dst写入的行被覆盖；

写入`dst[1][0]`, 不命中，加载L2的8字节的块到组1写入；

访问`src[1][0]`, 不命中，加载8字节的块到组1，此时`src[1][1]`也在组1了，

写入`dst[0][1]`, 不命中，加载L2的8字节块到组0，此时src的组0行被覆盖；

访问`src[1][1]`，命中；

写入`dst[1][1]`, 不命中，

A. 命中(h) Or 不命中(m)

dst数组:

|      | 列0  | 列1  |
| ---- | ---- | ---- |
| 0行  | m    | m    |
| 1行  | m    | m    |

src数组：

|      | 列0  | 列1  |
| ---- | ---- | ---- |
| 0行  | m    | m    |
| 1行  | m    | h    |

## 习题6.18

高速缓存：

| 组   |      | 块大小/Bytes |
| ---- | ---- | ------------ |
| 组0  |      | 16           |
| 组1  |      | 16           |
| ...  |      |              |
| 组63 |      | 16           |

- sizeof(int)=4
- grid内存地址0x0
- 冷高速缓存
- 唯一的内存访问为对数组grid的元素的访问，其他变量在寄存器中

```c
struct algae_pos {
    int x;
    int y;
};

struct algae_pos grid[16][16];
int total_x = 0, total_y = 0;
int i, j;

void main() {
    for (i = 0; i < 16; i++) {
        for (j = 0; j < 16; j++) {
            total_x += grid[i][j].x;
        }
    }
    
    for (i = 0; i < 16; i++) {
        for (j = 0; j < 16; j++) {
            total_y += grid[i][j].y;
        }
    }
}

```

grid数组总占用`16*16*8=1024 * 2 Bytes`, 高速缓存不能放下整个数组；每个缓存行2个结构；

| 组   | 块[0]           | 块[1]           | 块[2]           | 块[3]           |
| ---- | --------------- | --------------- | --------------- | --------------- |
| 0    | `grid[0][0].x`  | `grid[0][0].y`  | `grid[0][1].x`  | `grid[0][1].y`  |
| ...  | ...             |                 |                 |                 |
| 63   | `grid[7][14].x` | `grid[7][14].y` | `grid[7][15].x` | `grid[7][15].y` |

A. 高速缓存的读总数为 512

B. 缓存不命中的读总数：256

C. 不命中率 = 50%

## 习题6.19

基于习题6.18的假设，确定下列代码的高速缓存性能“

```c
	for (i = 0; i < 16; i++) {
        for (j = 0; j < 16; j++) {
            total_x += grid[j][i].x;
            total_y += grid[j][i].y;
        }
    }
```

A. 高速缓存的读总数为 512

B. 缓存不命中的读总数：256

C. 不命中率 = 50%

D. 如果高速缓存2048字节，每个缓存行的命中情况都是 m、h、h、h,不命中率 = 25%